/**
 * Generated by Scrooge
 *   version: 4.18.0
 *   rev: 19f0c3c1e92bca00860d6b0b3c7edea6702ab439
 *   built at: 20170609-100323
 */
package thrift

import com.twitter.scrooge.ThriftEnum
import scala.collection.immutable.{ Map => immutable$Map }

@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
case object Operation {

  val annotations: immutable$Map[String, String] = immutable$Map.empty

  case object Add extends thrift.Operation {
    val value: Int = 1
    val name: String = "Add"
    val originalName: String = "ADD"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeAdd = _root_.scala.Some(thrift.Operation.Add)

  case object Subtract extends thrift.Operation {
    val value: Int = 2
    val name: String = "Subtract"
    val originalName: String = "SUBTRACT"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeSubtract = _root_.scala.Some(thrift.Operation.Subtract)

  case object Multiply extends thrift.Operation {
    val value: Int = 3
    val name: String = "Multiply"
    val originalName: String = "MULTIPLY"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeMultiply = _root_.scala.Some(thrift.Operation.Multiply)

  case object Divide extends thrift.Operation {
    val value: Int = 4
    val name: String = "Divide"
    val originalName: String = "DIVIDE"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeDivide = _root_.scala.Some(thrift.Operation.Divide)

  case class EnumUnknownOperation(value: Int) extends thrift.Operation {
    val name: String = "EnumUnknownOperation" + value
    def originalName: String = name
  }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   */
  def apply(value: Int): thrift.Operation =
    value match {
      case 1 => thrift.Operation.Add
      case 2 => thrift.Operation.Subtract
      case 3 => thrift.Operation.Multiply
      case 4 => thrift.Operation.Divide
      case _ => throw new NoSuchElementException(value.toString)
    }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   * returns an EnumUnknownOperation(value) if the value is not found.
   * In particular this allows ignoring new values added to an enum
   * in the IDL on the producer side when the consumer was not updated.
   */
  def getOrUnknown(value: Int): thrift.Operation =
    get(value) match {
      case _root_.scala.Some(e) => e
      case _root_.scala.None => EnumUnknownOperation(value)
    }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   * Returns None if the value is not found
   */
  def get(value: Int): _root_.scala.Option[thrift.Operation] =
    value match {
      case 1 => _SomeAdd
      case 2 => _SomeSubtract
      case 3 => _SomeMultiply
      case 4 => _SomeDivide
      case _ => _root_.scala.None
    }

  def valueOf(name: String): _root_.scala.Option[thrift.Operation] =
    name.toLowerCase match {
      case "add" => _SomeAdd
      case "subtract" => _SomeSubtract
      case "multiply" => _SomeMultiply
      case "divide" => _SomeDivide
      case _ => _root_.scala.None
    }

  lazy val list: List[thrift.Operation] = scala.List[thrift.Operation](
    thrift.Operation.Add,
    thrift.Operation.Subtract,
    thrift.Operation.Multiply,
    thrift.Operation.Divide)
}

@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
sealed trait Operation extends ThriftEnum with Serializable